{"version":5,"vars":[{"line":2,"kind":2,"name":"strict","containerName":""},{"name":"warnings","containerName":"","line":3,"kind":2},{"kind":2,"line":5,"containerName":"App","name":"PrereqGrapher"},{"containerName":"Capture","name":"Tiny","kind":2,"line":6},{"line":7,"kind":2,"name":"JSON","containerName":"Config"},{"line":8,"kind":2,"containerName":"","name":"Cwd"},{"line":9,"kind":2,"name":"DDP","containerName":""},{"line":10,"kind":2,"containerName":"","name":"DBI"},{"line":11,"kind":2,"name":"Basename","containerName":"File"},{"line":12,"kind":2,"name":"Long","containerName":"Getopt"},{"name":"JSON","containerName":"","kind":2,"line":13},{"containerName":"Path","name":"Tiny","kind":2,"line":14},{"kind":2,"line":15,"containerName":"Perl","name":"Critic"},{"kind":2,"line":16,"containerName":"Perl::Metrics","name":"Simple"},{"containerName":"Pod::Simple","name":"Search","line":17,"kind":2},{"line":18,"kind":2,"containerName":"","name":"Safe"},{"containerName":null,"kind":13,"name":"$initialize","line":20,"definition":"my","localvar":"my"},{"line":22,"kind":12,"name":"GetOptions"},{"name":"$initialize","containerName":null,"line":23,"kind":13},{"containerName":null,"kind":13,"localvar":"my","name":"$dbh","line":26,"definition":"my"},{"line":26,"kind":12,"name":"DBI"},{"containerName":"main::","name":"connect","kind":12,"line":26},{"line":29,"kind":13,"name":"%initialize","containerName":null},{"line":32,"kind":12,"name":"_initialize_data"},{"localvar":"my","name":"$analyzer","line":35,"definition":"my","containerName":null,"kind":13},{"containerName":"Metrics::Simple","name":"Perl","line":35,"kind":12},{"line":35,"kind":12,"name":"new","containerName":"main::"},{"containerName":null,"kind":13,"localvar":"my","name":"$libs","definition":"my","line":36},{"containerName":null,"kind":13,"name":"$config","definition":"my","line":39,"localvar":"my"},{"line":39,"kind":12,"name":"Config","containerName":"JSON"},{"name":"new","containerName":"main::","line":39,"kind":12},{"definition":"my","line":41,"name":"$module_count","localvar":"my","kind":13,"containerName":null},{"line":42,"kind":13,"containerName":null,"name":"$config"},{"line":42,"kind":12,"name":"get","containerName":"main::"},{"containerName":null,"kind":13,"name":"$dpath","line":43,"definition":"my","localvar":"my"},{"line":44,"definition":"my","name":"$dir","localvar":"my","kind":13,"containerName":null},{"line":44,"kind":12,"name":"path"},{"kind":13,"line":44,"containerName":null,"name":"$dpath"},{"kind":13,"containerName":null,"line":45,"definition":"my","name":"$iter","localvar":"my"},{"kind":13,"line":45,"name":"$dir","containerName":null},{"name":"iterator","containerName":"main::","kind":12,"line":45},{"kind":12,"line":46,"name":"recurse"},{"name":"follow_symlinks","line":47,"kind":12},{"containerName":null,"kind":13,"name":"$path","line":50,"definition":"my","localvar":"my"},{"containerName":null,"name":"%iter","kind":13,"line":50},{"kind":13,"line":51,"name":"$path","containerName":null},{"kind":12,"line":51,"containerName":"main::","name":"is_dir"},{"kind":13,"line":51,"name":"$path","containerName":null},{"containerName":null,"kind":13,"localvar":"my","name":"$file","line":52,"definition":"my"},{"line":52,"kind":13,"containerName":null,"name":"$path"},{"name":"relative","containerName":"main::","kind":12,"line":52},{"kind":13,"containerName":null,"localvar":"my","line":54,"definition":"my","name":"$module"},{"kind":13,"line":55,"name":"$module","containerName":null},{"line":55,"kind":13,"containerName":null,"name":"$file"},{"name":"$module","containerName":null,"kind":13,"line":56},{"kind":13,"line":57,"containerName":null,"name":"$module"},{"containerName":null,"kind":13,"localvar":"my","name":"$filename","line":59,"definition":"my"},{"line":59,"kind":12,"name":"fileparse"},{"line":59,"kind":13,"name":"$file","containerName":null},{"kind":12,"line":60,"name":"_collect_git_data"},{"name":"path","line":60,"kind":12},{"kind":13,"line":60,"name":"$path","containerName":null},{"line":60,"kind":12,"containerName":"main::","name":"parent"},{"name":"stringify","containerName":"main::","line":60,"kind":12},{"line":60,"kind":13,"name":"$module","containerName":null},{"name":"$filename","containerName":null,"line":60,"kind":13},{"containerName":null,"name":"$config","line":60,"kind":13},{"line":60,"kind":12,"containerName":"main::","name":"get"},{"name":"$module_count","containerName":null,"line":64,"kind":13},{"line":66,"definition":"my","name":"$pod_score","localvar":"my","kind":13,"containerName":null},{"name":"_collect_pod_data","line":66,"kind":12},{"containerName":null,"name":"$module","line":66,"kind":13},{"name":"$file","containerName":null,"line":66,"kind":13},{"name":"_collect_metrics_data","line":67,"kind":12},{"kind":13,"line":67,"name":"$module","containerName":null},{"kind":13,"line":67,"containerName":null,"name":"$file"},{"kind":13,"line":67,"containerName":null,"name":"$pod_score"},{"name":"_collect_critic_data","line":68,"kind":12},{"containerName":null,"name":"$module","line":68,"kind":13},{"containerName":null,"name":"$file","kind":13,"line":68},{"name":"_collect_use_data","kind":12,"line":69},{"name":"$module","containerName":null,"kind":13,"line":69},{"line":69,"kind":13,"containerName":null,"name":"$file"},{"name":"_collect_git_commit_data","kind":12,"line":72},{"kind":13,"line":72,"name":"$config","containerName":null},{"containerName":"main::","name":"get","kind":12,"line":72},{"kind":13,"line":76,"containerName":null,"name":"$module_count"},{"name":"_collect_critic_data","definition":"sub","line":82,"signature":{"parameters":[{"label":"$module"},{"label":"$file"}],"documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data","label":"_collect_critic_data($module,$file)"},"children":[{"kind":13,"containerName":"_collect_critic_data","definition":"my","line":83,"name":"$module","localvar":"my"},{"name":"$file","containerName":"_collect_critic_data","kind":13,"line":83},{"localvar":"my","name":"@critic_data","definition":"my","line":85,"containerName":"_collect_critic_data","kind":13},{"kind":13,"containerName":"_collect_critic_data","line":86,"definition":"my","name":"$critic","localvar":"my"},{"containerName":"_collect_critic_data","name":"new","line":86,"kind":12},{"kind":13,"containerName":"_collect_critic_data","localvar":"my","definition":"my","line":87,"name":"@issues"},{"containerName":"_collect_critic_data","name":"$critic","line":87,"kind":13},{"kind":12,"line":87,"containerName":"_collect_critic_data","name":"critique"},{"line":87,"kind":13,"name":"$file","containerName":"_collect_critic_data"},{"kind":12,"line":87,"containerName":"_collect_critic_data","name":"stringify"},{"containerName":"_collect_critic_data","name":"@issues","kind":13,"line":89},{"containerName":"_collect_critic_data","name":"@critic_data","kind":13,"line":90},{"kind":12,"line":90,"containerName":"_collect_critic_data","name":"description"},{"kind":12,"line":90,"containerName":"_collect_critic_data","name":"line_number"},{"name":"source","containerName":"_collect_critic_data","kind":12,"line":90},{"line":90,"kind":12,"containerName":"_collect_critic_data","name":"explanation"},{"name":"$query","definition":"my","line":93,"localvar":"my","containerName":"_collect_critic_data","kind":13},{"localvar":"my","line":94,"definition":"my","name":"$stmt","kind":13,"containerName":"_collect_critic_data"},{"line":94,"kind":13,"containerName":"_collect_critic_data","name":"$dbh"},{"kind":12,"line":94,"containerName":"_collect_critic_data","name":"prepare"},{"containerName":"_collect_critic_data","name":"$query","line":94,"kind":13},{"kind":13,"line":96,"name":"@critic_data","containerName":"_collect_critic_data"},{"kind":13,"line":97,"containerName":"_collect_critic_data","name":"$stmt"},{"kind":12,"line":97,"containerName":"_collect_critic_data","name":"execute"},{"name":"$module","containerName":"_collect_critic_data","kind":13,"line":97}],"detail":"($module,$file)","containerName":"main::","range":{"end":{"line":101,"character":9999},"start":{"character":0,"line":82}},"kind":12},{"line":86,"kind":12,"containerName":"Critic","name":"Perl"},{"range":{"start":{"character":0,"line":107},"end":{"line":158,"character":9999}},"detail":"($file,$module,$filename,$gitlib)","containerName":"main::","kind":12,"name":"_collect_git_data","signature":{"parameters":[{"label":"$file"},{"label":"$module"},{"label":"$filename"},{"label":"$gitlib"}],"documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data","label":"_collect_git_data($file,$module,$filename,$gitlib)"},"line":107,"definition":"sub","children":[{"kind":13,"containerName":"_collect_git_data","localvar":"my","line":108,"definition":"my","name":"$file"},{"line":108,"kind":13,"name":"$module","containerName":"_collect_git_data"},{"kind":13,"line":108,"containerName":"_collect_git_data","name":"$filename"},{"name":"$gitlib","containerName":"_collect_git_data","line":108,"kind":13},{"localvar":"my","line":111,"definition":"my","name":"$cwd","kind":13,"containerName":"_collect_git_data"},{"kind":13,"containerName":"_collect_git_data","localvar":"my","definition":"my","line":112,"name":"$full_filename"},{"name":"$file","containerName":"_collect_git_data","kind":13,"line":112},{"line":112,"kind":13,"name":"$filename","containerName":"_collect_git_data"},{"containerName":"_collect_git_data","name":"$gitlib","kind":13,"line":114},{"name":"$gitdir","line":115,"definition":"my","localvar":"my","containerName":"_collect_git_data","kind":13},{"localvar":"my","name":"$gitlog","line":116,"definition":"my","containerName":"_collect_git_data","kind":13},{"containerName":"_collect_git_data","name":"$stderr","kind":13,"line":116},{"kind":13,"line":116,"name":"$exit","containerName":"_collect_git_data"},{"name":"$full_filename","containerName":"_collect_git_data","line":125,"kind":13},{"kind":13,"containerName":"_collect_git_data","localvar":"my","line":127,"definition":"my","name":"$latest_git_commit_data"},{"name":"$latest_git_commit_data","containerName":"_collect_git_data","kind":13,"line":128},{"containerName":"_collect_git_data","name":"$stderr","kind":13,"line":128},{"kind":13,"line":128,"containerName":"_collect_git_data","name":"$exit"},{"containerName":"_collect_git_data","name":"$full_filename","kind":13,"line":129},{"containerName":"_collect_git_data","kind":13,"localvar":"my","name":"$latest_git_commit_sha","line":130,"definition":"my"},{"name":"$commit_description","containerName":"_collect_git_data","line":130,"kind":13},{"kind":13,"line":130,"name":"$latest_git_commit_data","containerName":"_collect_git_data"},{"localvar":"my","definition":"my","line":132,"name":"$query","kind":13,"containerName":"_collect_git_data"},{"containerName":"_collect_git_data","kind":13,"localvar":"my","name":"$stmt","definition":"my","line":133},{"line":133,"kind":13,"containerName":"_collect_git_data","name":"$dbh"},{"containerName":"_collect_git_data","name":"prepare","line":133,"kind":12},{"kind":13,"line":133,"name":"$query","containerName":"_collect_git_data"},{"line":134,"kind":13,"name":"$stmt","containerName":"_collect_git_data"},{"containerName":"_collect_git_data","name":"execute","kind":12,"line":134},{"name":"$module","containerName":"_collect_git_data","kind":13,"line":136},{"localvar":"my","definition":"my","line":137,"name":"$git_sha","kind":13,"containerName":"_collect_git_data"},{"kind":13,"line":137,"containerName":"_collect_git_data","name":"$stmt"},{"name":"fetchrow_array","containerName":"_collect_git_data","kind":12,"line":137},{"containerName":"_collect_git_data","name":"$query","line":139,"kind":13},{"name":"$stmt","containerName":"_collect_git_data","line":140,"kind":13},{"name":"$dbh","containerName":"_collect_git_data","kind":13,"line":140},{"containerName":"_collect_git_data","name":"prepare","line":140,"kind":12},{"name":"$query","containerName":"_collect_git_data","line":140,"kind":13},{"name":"$initialize","containerName":"_collect_git_data","line":141,"kind":13},{"line":142,"kind":13,"name":"$git_sha","containerName":"_collect_git_data"},{"line":142,"kind":13,"containerName":"_collect_git_data","name":"$git_sha"},{"line":142,"kind":13,"containerName":"_collect_git_data","name":"$latest_git_commit_sha"},{"containerName":"_collect_git_data","name":"$module","kind":13,"line":147},{"line":148,"kind":13,"name":"$stmt","containerName":"_collect_git_data"},{"kind":12,"line":148,"containerName":"_collect_git_data","name":"execute"},{"kind":13,"line":149,"containerName":"_collect_git_data","name":"$module"},{"kind":13,"line":150,"containerName":"_collect_git_data","name":"$latest_git_commit_sha"},{"containerName":"_collect_git_data","name":"$gitlog","kind":13,"line":152},{"containerName":"_collect_git_data","name":"$cwd","kind":13,"line":155}]},{"name":"getcwd","kind":12,"line":111},{"kind":12,"line":115,"name":"cwd"},{"name":"capture","line":116,"kind":12},{"name":"capture","line":128,"kind":12},{"kind":12,"range":{"start":{"line":164,"character":0},"end":{"character":9999,"line":192}},"containerName":"main::","detail":"($gitlib)","signature":{"label":"_collect_git_commit_data($gitlib)","documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data","parameters":[{"label":"$gitlib"}]},"line":164,"definition":"sub","name":"_collect_git_commit_data","children":[{"containerName":"_collect_git_commit_data","kind":13,"localvar":"my","name":"$gitlib","line":165,"definition":"my"},{"containerName":"_collect_git_commit_data","kind":13,"localvar":"my","name":"$cwd","definition":"my","line":168},{"kind":13,"line":170,"name":"$gitlib","containerName":"_collect_git_commit_data"},{"containerName":"_collect_git_commit_data","kind":13,"localvar":"my","name":"$gitdir","line":171,"definition":"my"},{"containerName":"_collect_git_commit_data","kind":13,"localvar":"my","name":"$git_commits","definition":"my","line":172},{"kind":13,"line":172,"containerName":"_collect_git_commit_data","name":"$stderr"},{"containerName":"_collect_git_commit_data","name":"$exit","kind":13,"line":172},{"kind":13,"containerName":"_collect_git_commit_data","localvar":"my","line":175,"definition":"my","name":"$query"},{"containerName":"_collect_git_commit_data","kind":13,"localvar":"my","name":"$stmt","definition":"my","line":176},{"line":176,"kind":13,"name":"$dbh","containerName":"_collect_git_commit_data"},{"kind":12,"line":176,"containerName":"_collect_git_commit_data","name":"prepare"},{"containerName":"_collect_git_commit_data","name":"$query","kind":13,"line":176},{"kind":13,"containerName":"_collect_git_commit_data","definition":"my","line":178,"name":"@commits","localvar":"my"},{"kind":13,"line":178,"name":"$git_commits","containerName":"_collect_git_commit_data"},{"line":179,"kind":13,"name":"@commits","containerName":"_collect_git_commit_data"},{"localvar":"my","line":181,"definition":"my","name":"$count","kind":13,"containerName":"_collect_git_commit_data"},{"containerName":"_collect_git_commit_data","name":"$date","kind":13,"line":181},{"kind":13,"line":182,"containerName":"_collect_git_commit_data","name":"$stmt"},{"containerName":"_collect_git_commit_data","name":"execute","kind":12,"line":182},{"kind":13,"line":183,"name":"$date","containerName":"_collect_git_commit_data"},{"name":"$count","containerName":"_collect_git_commit_data","kind":13,"line":185},{"line":189,"kind":13,"containerName":"_collect_git_commit_data","name":"$cwd"}]},{"name":"getcwd","kind":12,"line":168},{"name":"cwd","line":171,"kind":12},{"name":"capture","line":172,"kind":12},{"children":[{"name":"$module","definition":"my","line":199,"localvar":"my","containerName":"_collect_metrics_data","kind":13},{"kind":13,"line":199,"containerName":"_collect_metrics_data","name":"$file"},{"kind":13,"line":199,"containerName":"_collect_metrics_data","name":"$pod_score"},{"localvar":"my","definition":"my","line":201,"name":"@file_array","kind":13,"containerName":"_collect_metrics_data"},{"line":201,"kind":13,"name":"$file","containerName":"_collect_metrics_data"},{"line":201,"kind":12,"containerName":"_collect_metrics_data","name":"stringify"},{"definition":"my","line":202,"name":"$analysis","localvar":"my","kind":13,"containerName":"_collect_metrics_data"},{"containerName":"_collect_metrics_data","name":"$analyzer","kind":13,"line":202},{"name":"analyze_files","containerName":"_collect_metrics_data","kind":12,"line":202},{"name":"@file_array","containerName":"_collect_metrics_data","line":202,"kind":13},{"kind":13,"containerName":"_collect_metrics_data","definition":"my","line":204,"name":"$query","localvar":"my"},{"localvar":"my","name":"$stmt","line":205,"definition":"my","containerName":"_collect_metrics_data","kind":13},{"name":"$dbh","containerName":"_collect_metrics_data","kind":13,"line":205},{"kind":12,"line":205,"name":"prepare","containerName":"_collect_metrics_data"},{"name":"$query","containerName":"_collect_metrics_data","kind":13,"line":205},{"line":207,"kind":13,"name":"$analysis","containerName":"_collect_metrics_data"},{"name":"subs","containerName":"_collect_metrics_data","kind":12,"line":207}],"signature":{"parameters":[{"label":"$module"},{"label":"$file"},{"label":"$pod_score"}],"documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data","label":"_collect_metrics_data($module,$file,$pod_score)"},"definition":"sub","line":198,"name":"_collect_metrics_data","kind":12,"range":{"end":{"character":9999,"line":207},"start":{"line":198,"character":0}},"detail":"($module,$file,$pod_score)","containerName":"main::"},{"name":"mccabe_complexity","kind":12,"line":208},{"kind":13,"line":209,"containerName":null,"name":"$stmt"},{"kind":12,"line":209,"name":"execute","containerName":"main::"},{"kind":13,"line":209,"containerName":null,"name":"%module"},{"kind":12,"line":209,"name":"name"},{"name":"mccabe_complexity","line":209,"kind":12},{"kind":12,"line":209,"name":"lines"},{"localvar":"my","line":213,"definition":"my","name":"$summary","kind":13,"containerName":null},{"name":"$analysis","containerName":null,"kind":13,"line":213},{"line":213,"kind":12,"name":"summary_stats","containerName":"main::"},{"kind":13,"containerName":null,"line":214,"definition":"my","name":"$lines","localvar":"my"},{"kind":13,"line":214,"containerName":null,"name":"$analysis"},{"line":214,"kind":12,"name":"lines","containerName":"main::"},{"kind":13,"line":215,"containerName":null,"name":"$query"},{"kind":13,"line":216,"containerName":null,"name":"$stmt"},{"line":216,"kind":13,"name":"$dbh","containerName":null},{"containerName":"main::","name":"prepare","line":216,"kind":12},{"name":"$query","containerName":null,"kind":13,"line":216},{"name":"$stmt","containerName":null,"kind":13,"line":217},{"name":"execute","containerName":"main::","line":217,"kind":12},{"name":"$module","containerName":null,"line":218,"kind":13},{"kind":13,"line":219,"containerName":null,"name":"%summary"},{"kind":12,"line":219,"name":"sub_complexity"},{"name":"mean","line":219,"kind":12},{"name":"%summary","containerName":null,"kind":13,"line":219},{"line":219,"kind":12,"name":"sub_complexity"},{"line":219,"kind":12,"name":"mean"},{"kind":13,"line":220,"containerName":null,"name":"%summary"},{"kind":12,"line":220,"name":"sub_complexity"},{"line":220,"kind":12,"name":"max"},{"kind":13,"line":221,"name":"$lines","containerName":null},{"containerName":null,"name":"$pod_score","line":222,"kind":13},{"line":223,"kind":13,"name":"$analysis","containerName":null},{"containerName":"main::","name":"sub_count","kind":12,"line":223},{"kind":12,"containerName":"main::","detail":"($module,$file)","range":{"end":{"character":9999,"line":253},"start":{"character":0,"line":233}},"definition":"sub","line":233,"signature":{"parameters":[{"label":"$module"},{"label":"$file"}],"documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data","label":"_collect_module_hierarchy_data($module,$file)"},"name":"_collect_module_hierarchy_data","children":[{"line":234,"definition":"my","name":"$module","localvar":"my","kind":13,"containerName":"_collect_module_hierarchy_data"},{"containerName":"_collect_module_hierarchy_data","name":"$file","kind":13,"line":234},{"localvar":"my","definition":"my","line":236,"name":"$git_commits","kind":13,"containerName":"_collect_module_hierarchy_data"},{"containerName":"_collect_module_hierarchy_data","name":"$stderr","line":236,"kind":13},{"name":"$exit","containerName":"_collect_module_hierarchy_data","line":236,"kind":13},{"localvar":"my","name":"$query","definition":"my","line":239,"containerName":"_collect_module_hierarchy_data","kind":13},{"localvar":"my","line":240,"definition":"my","name":"$stmt","kind":13,"containerName":"_collect_module_hierarchy_data"},{"kind":13,"line":240,"containerName":"_collect_module_hierarchy_data","name":"$dbh"},{"containerName":"_collect_module_hierarchy_data","name":"prepare","kind":12,"line":240},{"line":240,"kind":13,"containerName":"_collect_module_hierarchy_data","name":"$query"},{"kind":13,"containerName":"_collect_module_hierarchy_data","line":242,"definition":"my","name":"@commits","localvar":"my"},{"line":242,"kind":13,"name":"$git_commits","containerName":"_collect_module_hierarchy_data"},{"containerName":"_collect_module_hierarchy_data","name":"@commits","kind":13,"line":243},{"definition":"my","line":245,"name":"$count","localvar":"my","kind":13,"containerName":"_collect_module_hierarchy_data"},{"name":"$date","containerName":"_collect_module_hierarchy_data","kind":13,"line":245},{"containerName":"_collect_module_hierarchy_data","name":"$stmt","kind":13,"line":246},{"kind":12,"line":246,"name":"execute","containerName":"_collect_module_hierarchy_data"},{"containerName":"_collect_module_hierarchy_data","name":"$date","kind":13,"line":247},{"name":"$count","containerName":"_collect_module_hierarchy_data","line":249,"kind":13}]},{"line":236,"kind":12,"name":"capture"},{"children":[{"localvar":"my","definition":"my","line":262,"name":"$module","kind":13,"containerName":"_collect_pod_data"},{"line":262,"kind":13,"containerName":"_collect_pod_data","name":"$file"},{"containerName":"_collect_pod_data","kind":13,"localvar":"my","name":"$finder","line":264,"definition":"my"},{"kind":12,"line":264,"name":"new","containerName":"_collect_pod_data"},{"name":"$finder","containerName":"_collect_pod_data","line":265,"kind":13},{"line":265,"kind":12,"containerName":"_collect_pod_data","name":"contains_pod"},{"line":265,"kind":13,"name":"$file","containerName":"_collect_pod_data"}],"signature":{"documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD","label":"_collect_pod_data($module,$file)","parameters":[{"label":"$module"},{"label":"$file"}]},"line":261,"definition":"sub","name":"_collect_pod_data","kind":12,"range":{"end":{"line":270,"character":9999},"start":{"character":0,"line":261}},"containerName":"main::","detail":"($module,$file)"},{"name":"Pod","containerName":"Simple::Search","line":264,"kind":12},{"children":[{"containerName":"_collect_use_data","kind":13,"localvar":"my","name":"$module","definition":"my","line":277},{"line":277,"kind":13,"containerName":"_collect_use_data","name":"$file"},{"kind":13,"containerName":"_collect_use_data","definition":"my","line":280,"name":"$fh","localvar":"my"},{"containerName":"_collect_use_data","name":"$file","kind":13,"line":280},{"localvar":"my","name":"$filename","definition":"my","line":282,"containerName":"_collect_use_data","kind":13},{"name":"$file","containerName":"_collect_use_data","line":282,"kind":13},{"localvar":"my","name":"$file_data","definition":"my","line":284,"containerName":"_collect_use_data","kind":13},{"line":285,"kind":13,"containerName":"_collect_use_data","name":"$file"},{"name":"$filename","containerName":"_collect_use_data","kind":13,"line":286},{"line":295,"kind":13,"containerName":"_collect_use_data","name":"$fh"},{"line":297,"kind":13,"name":"$file_data","containerName":"_collect_use_data"},{"containerName":"_collect_use_data","name":"$file_data","line":298,"kind":13},{"kind":13,"line":299,"containerName":"_collect_use_data","name":"$file_data"},{"line":304,"kind":13,"containerName":"_collect_use_data","name":"$file_data"},{"name":"$file_data","containerName":"_collect_use_data","kind":13,"line":307},{"name":"$file_data","containerName":"_collect_use_data","kind":13,"line":310},{"name":"$file_data","containerName":"_collect_use_data","kind":13,"line":310},{"containerName":"_collect_use_data","name":"$file_data","kind":13,"line":320},{"line":322,"kind":13,"name":"$file_data","containerName":"_collect_use_data"},{"line":322,"kind":13,"containerName":"_collect_use_data","name":"$fh"},{"kind":13,"line":324,"containerName":"_collect_use_data","name":"$fh"},{"containerName":"_collect_use_data","kind":13,"localvar":"my","name":"$dependencies","definition":"my","line":326},{"name":"$file_data","containerName":"_collect_use_data","line":326,"kind":13},{"containerName":"_collect_use_data","name":"$module","line":326,"kind":13},{"containerName":"_collect_use_data","kind":13,"localvar":"my","name":"$inheritance","line":327,"definition":"my"},{"line":327,"kind":13,"name":"$file_data","containerName":"_collect_use_data"},{"kind":13,"line":327,"containerName":"_collect_use_data","name":"$module"},{"localvar":"my","name":"$query","definition":"my","line":329,"containerName":"_collect_use_data","kind":13},{"containerName":"_collect_use_data","kind":13,"name":"$stmt","line":330,"definition":"my","localvar":"my"},{"line":330,"kind":13,"containerName":"_collect_use_data","name":"$dbh"},{"name":"prepare","containerName":"_collect_use_data","kind":12,"line":330},{"kind":13,"line":330,"containerName":"_collect_use_data","name":"$query"},{"line":331,"kind":13,"containerName":"_collect_use_data","name":"$stmt"},{"kind":12,"line":331,"name":"execute","containerName":"_collect_use_data"},{"containerName":"_collect_use_data","name":"$module","line":331,"kind":13},{"kind":13,"line":331,"name":"$dependencies","containerName":"_collect_use_data"},{"line":333,"kind":13,"name":"$query","containerName":"_collect_use_data"},{"line":334,"kind":13,"name":"$stmt","containerName":"_collect_use_data"},{"containerName":"_collect_use_data","name":"$dbh","line":334,"kind":13},{"line":334,"kind":12,"containerName":"_collect_use_data","name":"prepare"},{"line":334,"kind":13,"name":"$query","containerName":"_collect_use_data"},{"containerName":"_collect_use_data","name":"$stmt","kind":13,"line":335},{"line":335,"kind":12,"containerName":"_collect_use_data","name":"execute"},{"line":335,"kind":13,"name":"$module","containerName":"_collect_use_data"},{"kind":13,"line":335,"containerName":"_collect_use_data","name":"$inheritance"},{"containerName":"_collect_use_data","name":"$file_data","kind":13,"line":337}],"definition":"sub","line":276,"signature":{"label":"_collect_use_data($module,$file)","documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD\n\n\nsub _collect_pod_data {\n    my ( $module, $file ) = @_;\n\n    my $finder = Pod::Simple::Search->new;\n    if ( $finder->contains_pod( $file ) ) {\n        return 2;\n    }\n\n    return 1;\n}\n\n=head2 _collect_use_data","parameters":[{"label":"$module"},{"label":"$file"}]},"name":"_collect_use_data","kind":12,"containerName":"main::","detail":"($module,$file)","range":{"end":{"line":338,"character":9999},"start":{"character":0,"line":276}}},{"name":"_parse_package","kind":12,"line":304},{"name":"_parse_dependencies","kind":12,"line":320},{"name":"_parse_inheritance","line":322,"kind":12},{"name":"data","kind":12,"line":326},{"name":"depends_on","line":326,"kind":12},{"name":"data","line":327,"kind":12},{"kind":12,"line":327,"name":"parent"},{"name":"encode_json","kind":12,"line":331},{"name":"encode_json","kind":12,"line":335},{"containerName":"main::","detail":"($file,$module,$filename,$gitlib)","range":{"start":{"line":344,"character":0},"end":{"character":9999,"line":371}},"kind":12,"children":[{"localvar":"my","definition":"my","line":345,"name":"$file","kind":13,"containerName":"_get_latest_commit"},{"name":"$module","containerName":"_get_latest_commit","kind":13,"line":345},{"kind":13,"line":345,"containerName":"_get_latest_commit","name":"$filename"},{"containerName":"_get_latest_commit","name":"$gitlib","kind":13,"line":345},{"kind":13,"containerName":"_get_latest_commit","localvar":"my","definition":"my","line":348,"name":"$cwd"},{"kind":13,"containerName":"_get_latest_commit","definition":"my","line":349,"name":"$full_filename","localvar":"my"},{"line":349,"kind":13,"name":"$file","containerName":"_get_latest_commit"},{"containerName":"_get_latest_commit","name":"$filename","kind":13,"line":349},{"line":351,"kind":13,"containerName":"_get_latest_commit","name":"$gitlib"},{"name":"$gitdir","definition":"my","line":352,"localvar":"my","containerName":"_get_latest_commit","kind":13},{"definition":"my","line":353,"name":"$latest_git_commit_sha","localvar":"my","kind":13,"containerName":"_get_latest_commit"},{"name":"$stderr","containerName":"_get_latest_commit","line":353,"kind":13},{"containerName":"_get_latest_commit","name":"$exit","line":353,"kind":13},{"kind":13,"line":354,"name":"$full_filename","containerName":"_get_latest_commit"},{"localvar":"my","name":"$status","line":357,"definition":"my","containerName":"_get_latest_commit","kind":13},{"kind":13,"containerName":"_get_latest_commit","localvar":"my","line":358,"definition":"my","name":"$query"},{"definition":"my","line":359,"name":"$stmt","localvar":"my","kind":13,"containerName":"_get_latest_commit"},{"line":359,"kind":13,"containerName":"_get_latest_commit","name":"$dbh"},{"name":"prepare","containerName":"_get_latest_commit","line":359,"kind":12},{"line":359,"kind":13,"name":"$query","containerName":"_get_latest_commit"},{"kind":13,"line":360,"name":"$stmt","containerName":"_get_latest_commit"},{"kind":12,"line":360,"name":"execute","containerName":"_get_latest_commit"},{"containerName":"_get_latest_commit","name":"$module","kind":13,"line":360},{"containerName":"_get_latest_commit","kind":13,"localvar":"my","name":"$git_sha","line":361,"definition":"my"},{"name":"$stmt","containerName":"_get_latest_commit","kind":13,"line":361},{"line":361,"kind":12,"name":"fetchrow_array","containerName":"_get_latest_commit"},{"line":363,"kind":13,"name":"$git_sha","containerName":"_get_latest_commit"},{"containerName":"_get_latest_commit","name":"$latest_git_commit_sha","kind":13,"line":363},{"kind":13,"line":364,"containerName":"_get_latest_commit","name":"$status"},{"name":"$cwd","containerName":"_get_latest_commit","kind":13,"line":368},{"containerName":"_get_latest_commit","name":"$status","kind":13,"line":370}],"name":"_get_latest_commit","line":344,"definition":"sub","signature":{"label":"_get_latest_commit($file,$module,$filename,$gitlib)","documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD\n\n\nsub _collect_pod_data {\n    my ( $module, $file ) = @_;\n\n    my $finder = Pod::Simple::Search->new;\n    if ( $finder->contains_pod( $file ) ) {\n        return 2;\n    }\n\n    return 1;\n}\n\n=head2 _collect_use_data\n\n\nsub _collect_use_data {\n    my ( $module, $file ) = @_;\n  \n    # go through the file and try to find out some things\n    open my $fh, '<', $file or do { warn(\"Can't open file $file for read: $!\"); return undef; };\n\n    (my $filename = $file) =~ s/^\\.//;\n\n    my $file_data = {\n        'file'          => $file,\n        'filename'      => $filename,\n        'data'          => {},\n        'seen'          => {},\n        'source'        => {},\n        'in_pod'        => undef,\n        'curr_pkg'      => undef,\n        'curr_method'   => undef,\n    };\n\n    while (<$fh>) {\n        s/\\r?\\n$//;\n        $file_data->{'in_pod'} = 1 if m/^=\\w+/ && !m/^=cut/;\n        if ($file_data->{'in_pod'}) {\n            $file_data->{'in_pod'} = 0 if /^=cut/;\n            next;\n        }\n        last if m/^\\s*__(END|DATA)__/;\n\n        _parse_package( $file_data, $_ );\n        \n        # skip lines which do not belong to package namespace\n        next if !$file_data->{'curr_pkg'};\n        \n        # append current line to package source\n        $file_data->{'source'}->{$file_data->{'curr_pkg'}} .= $_ . \"\\n\";\n\n        ## - all commented out for now - will be revisted ...\n        # count non-empty lines\n        #$self->count_package_lines($_);\n        \n        #$self->parse_sub($_);\n        #$self->parse_super($_);\n        #$self->parse_method_call($_);\n\n        _parse_dependencies( $file_data, $_ );\n\n        _parse_inheritance( $file_data, $_, $fh );\n    }\n    close $fh;\n\n    my $dependencies = $file_data->{data}->{$module}->{depends_on};\n    my $inheritance  = $file_data->{data}->{$module}->{parent};\n\n    my $query = \"insert into dependencies (module, dependencies) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($dependencies) );\n\n    $query = \"insert into inheritance (module, inheritance) values(?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($inheritance) );\n\n    return $file_data->{'data'};\n}\n\n=head2 _get_latest_commit","parameters":[{"label":"$file"},{"label":"$module"},{"label":"$filename"},{"label":"$gitlib"}]}},{"name":"getcwd","line":348,"kind":12},{"line":352,"kind":12,"name":"cwd"},{"kind":12,"line":353,"name":"capture"},{"children":[{"containerName":"_initialize_data","kind":13,"localvar":"my","name":"$query","line":380,"definition":"my"},{"containerName":"_initialize_data","kind":13,"localvar":"my","name":"$stmt","definition":"my","line":381},{"kind":13,"line":381,"name":"$dbh","containerName":"_initialize_data"},{"kind":12,"line":381,"name":"prepare","containerName":"_initialize_data"},{"kind":13,"line":381,"name":"$query","containerName":"_initialize_data"},{"line":382,"kind":13,"containerName":"_initialize_data","name":"$stmt"},{"containerName":"_initialize_data","name":"execute","line":382,"kind":12},{"kind":13,"line":384,"name":"$query","containerName":"_initialize_data"},{"name":"$stmt","containerName":"_initialize_data","line":385,"kind":13},{"line":385,"kind":13,"containerName":"_initialize_data","name":"$dbh"},{"name":"prepare","containerName":"_initialize_data","kind":12,"line":385},{"containerName":"_initialize_data","name":"$query","kind":13,"line":385},{"containerName":"_initialize_data","name":"$stmt","kind":13,"line":386},{"line":386,"kind":12,"name":"execute","containerName":"_initialize_data"},{"line":388,"kind":13,"containerName":"_initialize_data","name":"$query"},{"name":"$stmt","containerName":"_initialize_data","line":389,"kind":13},{"containerName":"_initialize_data","name":"$dbh","kind":13,"line":389},{"name":"prepare","containerName":"_initialize_data","kind":12,"line":389},{"name":"$query","containerName":"_initialize_data","line":389,"kind":13},{"kind":13,"line":390,"containerName":"_initialize_data","name":"$stmt"},{"kind":12,"line":390,"name":"execute","containerName":"_initialize_data"},{"kind":13,"line":392,"containerName":"_initialize_data","name":"$query"},{"line":393,"kind":13,"name":"$stmt","containerName":"_initialize_data"},{"line":393,"kind":13,"containerName":"_initialize_data","name":"$dbh"},{"containerName":"_initialize_data","name":"prepare","kind":12,"line":393},{"kind":13,"line":393,"name":"$query","containerName":"_initialize_data"},{"kind":13,"line":394,"name":"$stmt","containerName":"_initialize_data"},{"name":"execute","containerName":"_initialize_data","line":394,"kind":12},{"kind":13,"line":396,"containerName":"_initialize_data","name":"$query"},{"name":"$stmt","containerName":"_initialize_data","kind":13,"line":397},{"name":"$dbh","containerName":"_initialize_data","line":397,"kind":13},{"kind":12,"line":397,"containerName":"_initialize_data","name":"prepare"},{"kind":13,"line":397,"name":"$query","containerName":"_initialize_data"},{"containerName":"_initialize_data","name":"$stmt","kind":13,"line":398},{"name":"execute","containerName":"_initialize_data","kind":12,"line":398},{"containerName":"_initialize_data","name":"$query","line":400,"kind":13},{"kind":13,"line":401,"name":"$stmt","containerName":"_initialize_data"},{"kind":13,"line":401,"containerName":"_initialize_data","name":"$dbh"},{"name":"prepare","containerName":"_initialize_data","line":401,"kind":12},{"kind":13,"line":401,"containerName":"_initialize_data","name":"$query"},{"kind":13,"line":402,"containerName":"_initialize_data","name":"$stmt"},{"containerName":"_initialize_data","name":"execute","line":402,"kind":12},{"name":"$query","containerName":"_initialize_data","line":404,"kind":13},{"name":"$stmt","containerName":"_initialize_data","line":405,"kind":13},{"containerName":"_initialize_data","name":"$dbh","line":405,"kind":13},{"name":"prepare","containerName":"_initialize_data","kind":12,"line":405},{"line":405,"kind":13,"name":"$query","containerName":"_initialize_data"},{"name":"$stmt","containerName":"_initialize_data","line":406,"kind":13},{"kind":12,"line":406,"containerName":"_initialize_data","name":"execute"}],"name":"_initialize_data","definition":"sub","line":379,"containerName":"main::","range":{"start":{"line":379,"character":0},"end":{"character":9999,"line":409}},"kind":12},{"name":"_parse_dependencies","signature":{"label":"_parse_dependencies($file_data,$line)","documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD\n\n\nsub _collect_pod_data {\n    my ( $module, $file ) = @_;\n\n    my $finder = Pod::Simple::Search->new;\n    if ( $finder->contains_pod( $file ) ) {\n        return 2;\n    }\n\n    return 1;\n}\n\n=head2 _collect_use_data\n\n\nsub _collect_use_data {\n    my ( $module, $file ) = @_;\n  \n    # go through the file and try to find out some things\n    open my $fh, '<', $file or do { warn(\"Can't open file $file for read: $!\"); return undef; };\n\n    (my $filename = $file) =~ s/^\\.//;\n\n    my $file_data = {\n        'file'          => $file,\n        'filename'      => $filename,\n        'data'          => {},\n        'seen'          => {},\n        'source'        => {},\n        'in_pod'        => undef,\n        'curr_pkg'      => undef,\n        'curr_method'   => undef,\n    };\n\n    while (<$fh>) {\n        s/\\r?\\n$//;\n        $file_data->{'in_pod'} = 1 if m/^=\\w+/ && !m/^=cut/;\n        if ($file_data->{'in_pod'}) {\n            $file_data->{'in_pod'} = 0 if /^=cut/;\n            next;\n        }\n        last if m/^\\s*__(END|DATA)__/;\n\n        _parse_package( $file_data, $_ );\n        \n        # skip lines which do not belong to package namespace\n        next if !$file_data->{'curr_pkg'};\n        \n        # append current line to package source\n        $file_data->{'source'}->{$file_data->{'curr_pkg'}} .= $_ . \"\\n\";\n\n        ## - all commented out for now - will be revisted ...\n        # count non-empty lines\n        #$self->count_package_lines($_);\n        \n        #$self->parse_sub($_);\n        #$self->parse_super($_);\n        #$self->parse_method_call($_);\n\n        _parse_dependencies( $file_data, $_ );\n\n        _parse_inheritance( $file_data, $_, $fh );\n    }\n    close $fh;\n\n    my $dependencies = $file_data->{data}->{$module}->{depends_on};\n    my $inheritance  = $file_data->{data}->{$module}->{parent};\n\n    my $query = \"insert into dependencies (module, dependencies) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($dependencies) );\n\n    $query = \"insert into inheritance (module, inheritance) values(?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($inheritance) );\n\n    return $file_data->{'data'};\n}\n\n=head2 _get_latest_commit\n\n\nsub _get_latest_commit {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $latest_git_commit_sha, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename . \" | awk '{print $1;}'\" ) };\n\n    # have I got a more recent commit ....\n    my $status = 0;\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    if ( $git_sha eq $latest_git_commit_sha ) {\n        $status = 1;\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return $status;\n}\n\n=head2 _initialize_data\n\nReset everything before scanning the specified repos\n\n\nsub _initialize_data {\n    my $query = \"delete from critic\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from metrics\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from summary\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from dependencies\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from inheritance\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitlog\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitcommits\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    return;\n}\n\n=head2 _parse_dependencies","parameters":[{"label":"$file_data"},{"label":"$line"}]},"line":415,"definition":"sub","children":[{"name":"$file_data","definition":"my","line":416,"localvar":"my","containerName":"_parse_dependencies","kind":13},{"kind":13,"line":416,"name":"$line","containerName":"_parse_dependencies"},{"name":"$line","containerName":"_parse_dependencies","kind":13,"line":419},{"line":421,"kind":13,"containerName":"_parse_dependencies","name":"$file_data"},{"line":421,"kind":13,"containerName":"_parse_dependencies","name":"$file_data"},{"line":424,"kind":13,"name":"$line","containerName":"_parse_dependencies"},{"containerName":"_parse_dependencies","kind":13,"name":"$file","definition":"my","line":426,"localvar":"my"},{"containerName":"_parse_dependencies","name":"$file","line":427,"kind":13},{"line":428,"kind":13,"containerName":"_parse_dependencies","name":"$file_data"},{"containerName":"_parse_dependencies","name":"$file_data","line":428,"kind":13},{"kind":13,"line":428,"name":"$file","containerName":"_parse_dependencies"},{"line":432,"kind":13,"containerName":"_parse_dependencies","name":"$line"},{"kind":13,"containerName":"_parse_dependencies","localvar":"my","definition":"my","line":433,"name":"$required"},{"line":434,"kind":13,"name":"$required","containerName":"_parse_dependencies"},{"name":"$file_data","containerName":"_parse_dependencies","line":435,"kind":13},{"containerName":"_parse_dependencies","name":"$file_data","kind":13,"line":435},{"containerName":"_parse_dependencies","name":"$required","kind":13,"line":435},{"line":437,"kind":13,"name":"$required","containerName":"_parse_dependencies"},{"containerName":"_parse_dependencies","name":"$required","kind":13,"line":438},{"containerName":"_parse_dependencies","name":"$required","line":439,"kind":13},{"name":"$file_data","containerName":"_parse_dependencies","kind":13,"line":440},{"name":"$file_data","containerName":"_parse_dependencies","kind":13,"line":440},{"kind":13,"line":440,"name":"$required","containerName":"_parse_dependencies"},{"kind":13,"line":446,"name":"$required","containerName":"_parse_dependencies"},{"containerName":"_parse_dependencies","name":"$required","kind":13,"line":447},{"line":451,"kind":13,"name":"$file_data","containerName":"_parse_dependencies"}],"range":{"end":{"line":452,"character":9999},"start":{"character":0,"line":415}},"containerName":"main::","detail":"($file_data,$line)","kind":12},{"line":421,"kind":12,"name":"_util_dpush"},{"line":428,"kind":12,"name":"_util_dpush"},{"name":"_util_dpush","kind":12,"line":435},{"kind":12,"line":440,"name":"_util_dpush"},{"name":"_parse_inheritance","signature":{"label":"_parse_inheritance($file_data,$line,$fh)","documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD\n\n\nsub _collect_pod_data {\n    my ( $module, $file ) = @_;\n\n    my $finder = Pod::Simple::Search->new;\n    if ( $finder->contains_pod( $file ) ) {\n        return 2;\n    }\n\n    return 1;\n}\n\n=head2 _collect_use_data\n\n\nsub _collect_use_data {\n    my ( $module, $file ) = @_;\n  \n    # go through the file and try to find out some things\n    open my $fh, '<', $file or do { warn(\"Can't open file $file for read: $!\"); return undef; };\n\n    (my $filename = $file) =~ s/^\\.//;\n\n    my $file_data = {\n        'file'          => $file,\n        'filename'      => $filename,\n        'data'          => {},\n        'seen'          => {},\n        'source'        => {},\n        'in_pod'        => undef,\n        'curr_pkg'      => undef,\n        'curr_method'   => undef,\n    };\n\n    while (<$fh>) {\n        s/\\r?\\n$//;\n        $file_data->{'in_pod'} = 1 if m/^=\\w+/ && !m/^=cut/;\n        if ($file_data->{'in_pod'}) {\n            $file_data->{'in_pod'} = 0 if /^=cut/;\n            next;\n        }\n        last if m/^\\s*__(END|DATA)__/;\n\n        _parse_package( $file_data, $_ );\n        \n        # skip lines which do not belong to package namespace\n        next if !$file_data->{'curr_pkg'};\n        \n        # append current line to package source\n        $file_data->{'source'}->{$file_data->{'curr_pkg'}} .= $_ . \"\\n\";\n\n        ## - all commented out for now - will be revisted ...\n        # count non-empty lines\n        #$self->count_package_lines($_);\n        \n        #$self->parse_sub($_);\n        #$self->parse_super($_);\n        #$self->parse_method_call($_);\n\n        _parse_dependencies( $file_data, $_ );\n\n        _parse_inheritance( $file_data, $_, $fh );\n    }\n    close $fh;\n\n    my $dependencies = $file_data->{data}->{$module}->{depends_on};\n    my $inheritance  = $file_data->{data}->{$module}->{parent};\n\n    my $query = \"insert into dependencies (module, dependencies) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($dependencies) );\n\n    $query = \"insert into inheritance (module, inheritance) values(?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($inheritance) );\n\n    return $file_data->{'data'};\n}\n\n=head2 _get_latest_commit\n\n\nsub _get_latest_commit {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $latest_git_commit_sha, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename . \" | awk '{print $1;}'\" ) };\n\n    # have I got a more recent commit ....\n    my $status = 0;\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    if ( $git_sha eq $latest_git_commit_sha ) {\n        $status = 1;\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return $status;\n}\n\n=head2 _initialize_data\n\nReset everything before scanning the specified repos\n\n\nsub _initialize_data {\n    my $query = \"delete from critic\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from metrics\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from summary\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from dependencies\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from inheritance\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitlog\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitcommits\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    return;\n}\n\n=head2 _parse_dependencies\n\n\nsub _parse_dependencies {\n    my ($file_data, $line) = @_;\n    \n    # need to process 'use parent *****' in DBIX resultset classes.\n    if ( $line =~ m/^\\s*use\\s+([\\w\\:]+)/ ) {\n        if ( $1 ne \"strict\" and $1 ne \"warnings\" and $1 ne \"parent\" and $1 ne 'base' and $1 ne 'namespace::autoclean') {\n            $file_data = _util_dpush($file_data, 'depends_on', $1);\n        }\n    }\n    if ( $line =~ m/^\\s*use\\s+([\\w\\:]+)\\s(\\S+)/ ) {\n        if ( $1 eq 'parent' or $1 eq 'base' ) {\n            my $file = $2;\n            $file =~ s/\\'|\\;//g;\n            $file_data = _util_dpush($file_data, 'depends_on', $file);\n        }\n    }\n\n    if ($line =~ m/^\\s*require\\s+([^\\s;]+)/) { # \"require Bar;\" or \"require 'Foo/Bar.pm' if $wibble;'\n        my $required = $1;\n        if ($required =~ m/^([\\w\\:]+)$/) {\n            $file_data = _util_dpush($file_data, 'depends_on', $required);\n        }\n        elsif ($required =~ m/^[\"'](.*?\\.pm)[\"']$/) { # simple Foo/Bar.pm case\n            ($required = $1) =~ s/\\.pm$//;\n            $required =~ s!/!::!g;\n            $file_data = _util_dpush($file_data, 'depends_on', $required);\n        }\n        else {\n            warn \"Can't interpret $line at line $. in $file_data->{file}\\n\"\n                unless m!sys/syscall.ph!\n                    or m!dumpvar.pl!\n                    or $required =~ /^\\$/   # dynamic 'require'\n                    or $required =~ /^5\\./;\n        }\n    }\n\n    return $file_data;\n}\n\n=head2 _parse_inheritance","parameters":[{"label":"$file_data"},{"label":"$line"},{"label":"$fh"}]},"definition":"sub","line":458,"children":[{"containerName":"_parse_inheritance","kind":13,"localvar":"my","name":"$file_data","line":459,"definition":"my"},{"name":"$line","containerName":"_parse_inheritance","line":459,"kind":13},{"name":"$fh","containerName":"_parse_inheritance","line":459,"kind":13},{"kind":13,"line":462,"name":"$line","containerName":"_parse_inheritance"},{"containerName":"_parse_inheritance","kind":13,"localvar":"my","name":"$list","line":463,"definition":"my"},{"name":"$list","containerName":"_parse_inheritance","line":464,"kind":13},{"containerName":"_parse_inheritance","name":"$list","line":465,"kind":13},{"line":465,"kind":13,"containerName":"_parse_inheritance","name":"$fh"},{"containerName":"_parse_inheritance","name":"$list","line":468,"kind":13},{"line":470,"kind":13,"name":"$list","containerName":"_parse_inheritance"},{"kind":13,"containerName":"_parse_inheritance","definition":"my","line":471,"name":"@mods","localvar":"my"},{"kind":12,"line":471,"containerName":"_parse_inheritance","name":"new"},{"kind":12,"line":471,"name":"reval","containerName":"_parse_inheritance"},{"kind":13,"line":471,"name":"$list","containerName":"_parse_inheritance"},{"name":"$mod","line":473,"definition":"my","localvar":"my","containerName":"_parse_inheritance","kind":13},{"name":"@mods","containerName":"_parse_inheritance","kind":13,"line":473},{"line":474,"kind":13,"name":"$file_data","containerName":"_parse_inheritance"},{"kind":13,"line":474,"name":"$file_data","containerName":"_parse_inheritance"},{"kind":13,"line":474,"containerName":"_parse_inheritance","name":"$mod"},{"containerName":"_parse_inheritance","name":"$line","line":479,"kind":13},{"containerName":"_parse_inheritance","kind":13,"name":"$list","definition":"my","line":480,"localvar":"my"},{"kind":13,"line":481,"containerName":"_parse_inheritance","name":"$list"},{"line":482,"definition":"my","name":"@mods","localvar":"my","kind":13,"containerName":"_parse_inheritance"},{"kind":12,"line":482,"containerName":"_parse_inheritance","name":"new"},{"name":"reval","containerName":"_parse_inheritance","kind":12,"line":482},{"line":482,"kind":13,"containerName":"_parse_inheritance","name":"$list"},{"containerName":"_parse_inheritance","kind":13,"localvar":"my","name":"$mod","definition":"my","line":483},{"name":"@mods","containerName":"_parse_inheritance","line":483,"kind":13},{"containerName":"_parse_inheritance","name":"$file_data","kind":13,"line":484},{"name":"$file_data","containerName":"_parse_inheritance","kind":13,"line":484},{"kind":13,"line":484,"containerName":"_parse_inheritance","name":"$mod"},{"name":"$line","containerName":"_parse_inheritance","line":488,"kind":13},{"localvar":"my","definition":"my","line":489,"name":"$list","kind":13,"containerName":"_parse_inheritance"},{"containerName":"_parse_inheritance","name":"$list","kind":13,"line":490},{"name":"@mods","definition":"my","line":491,"localvar":"my","containerName":"_parse_inheritance","kind":13},{"kind":12,"line":491,"name":"new","containerName":"_parse_inheritance"},{"containerName":"_parse_inheritance","name":"reval","kind":12,"line":491},{"kind":13,"line":491,"name":"$list","containerName":"_parse_inheritance"},{"containerName":"_parse_inheritance","kind":13,"name":"$mod","definition":"my","line":492,"localvar":"my"},{"kind":13,"line":492,"name":"@mods","containerName":"_parse_inheritance"},{"containerName":"_parse_inheritance","name":"$file_data","line":493,"kind":13},{"line":493,"kind":13,"name":"$file_data","containerName":"_parse_inheritance"},{"name":"$mod","containerName":"_parse_inheritance","line":493,"kind":13},{"line":497,"kind":13,"containerName":"_parse_inheritance","name":"$file_data"}],"range":{"start":{"line":458,"character":0},"end":{"line":498,"character":9999}},"detail":"($file_data,$line,$fh)","containerName":"main::","kind":12},{"name":"Safe","line":471,"kind":12},{"line":474,"kind":12,"name":"_util_dpush"},{"line":482,"kind":12,"name":"Safe"},{"name":"_util_dpush","line":484,"kind":12},{"kind":12,"line":491,"name":"Safe"},{"name":"_util_dpush","kind":12,"line":493},{"kind":12,"containerName":"main::","detail":"($file_data,$line)","range":{"start":{"character":0,"line":504},"end":{"character":9999,"line":527}},"children":[{"kind":13,"containerName":"_parse_package","line":505,"definition":"my","name":"$file_data","localvar":"my"},{"name":"$line","containerName":"_parse_package","line":505,"kind":13},{"line":508,"kind":13,"name":"$line","containerName":"_parse_package"},{"containerName":"_parse_package","kind":13,"localvar":"my","name":"$curr_pkg","definition":"my","line":509},{"kind":13,"line":510,"name":"$file_data","containerName":"_parse_package"},{"name":"$curr_pkg","containerName":"_parse_package","kind":13,"line":510},{"kind":13,"line":511,"name":"$file_data","containerName":"_parse_package"},{"line":511,"kind":13,"containerName":"_parse_package","name":"$curr_pkg"},{"line":512,"kind":13,"containerName":"_parse_package","name":"$file_data"},{"line":513,"kind":13,"containerName":"_parse_package","name":"$file_data"},{"containerName":"_parse_package","name":"$curr_pkg","kind":13,"line":514},{"containerName":"_parse_package","name":"$file_data","line":526,"kind":13}],"line":504,"definition":"sub","signature":{"documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD\n\n\nsub _collect_pod_data {\n    my ( $module, $file ) = @_;\n\n    my $finder = Pod::Simple::Search->new;\n    if ( $finder->contains_pod( $file ) ) {\n        return 2;\n    }\n\n    return 1;\n}\n\n=head2 _collect_use_data\n\n\nsub _collect_use_data {\n    my ( $module, $file ) = @_;\n  \n    # go through the file and try to find out some things\n    open my $fh, '<', $file or do { warn(\"Can't open file $file for read: $!\"); return undef; };\n\n    (my $filename = $file) =~ s/^\\.//;\n\n    my $file_data = {\n        'file'          => $file,\n        'filename'      => $filename,\n        'data'          => {},\n        'seen'          => {},\n        'source'        => {},\n        'in_pod'        => undef,\n        'curr_pkg'      => undef,\n        'curr_method'   => undef,\n    };\n\n    while (<$fh>) {\n        s/\\r?\\n$//;\n        $file_data->{'in_pod'} = 1 if m/^=\\w+/ && !m/^=cut/;\n        if ($file_data->{'in_pod'}) {\n            $file_data->{'in_pod'} = 0 if /^=cut/;\n            next;\n        }\n        last if m/^\\s*__(END|DATA)__/;\n\n        _parse_package( $file_data, $_ );\n        \n        # skip lines which do not belong to package namespace\n        next if !$file_data->{'curr_pkg'};\n        \n        # append current line to package source\n        $file_data->{'source'}->{$file_data->{'curr_pkg'}} .= $_ . \"\\n\";\n\n        ## - all commented out for now - will be revisted ...\n        # count non-empty lines\n        #$self->count_package_lines($_);\n        \n        #$self->parse_sub($_);\n        #$self->parse_super($_);\n        #$self->parse_method_call($_);\n\n        _parse_dependencies( $file_data, $_ );\n\n        _parse_inheritance( $file_data, $_, $fh );\n    }\n    close $fh;\n\n    my $dependencies = $file_data->{data}->{$module}->{depends_on};\n    my $inheritance  = $file_data->{data}->{$module}->{parent};\n\n    my $query = \"insert into dependencies (module, dependencies) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($dependencies) );\n\n    $query = \"insert into inheritance (module, inheritance) values(?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($inheritance) );\n\n    return $file_data->{'data'};\n}\n\n=head2 _get_latest_commit\n\n\nsub _get_latest_commit {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $latest_git_commit_sha, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename . \" | awk '{print $1;}'\" ) };\n\n    # have I got a more recent commit ....\n    my $status = 0;\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    if ( $git_sha eq $latest_git_commit_sha ) {\n        $status = 1;\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return $status;\n}\n\n=head2 _initialize_data\n\nReset everything before scanning the specified repos\n\n\nsub _initialize_data {\n    my $query = \"delete from critic\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from metrics\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from summary\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from dependencies\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from inheritance\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitlog\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitcommits\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    return;\n}\n\n=head2 _parse_dependencies\n\n\nsub _parse_dependencies {\n    my ($file_data, $line) = @_;\n    \n    # need to process 'use parent *****' in DBIX resultset classes.\n    if ( $line =~ m/^\\s*use\\s+([\\w\\:]+)/ ) {\n        if ( $1 ne \"strict\" and $1 ne \"warnings\" and $1 ne \"parent\" and $1 ne 'base' and $1 ne 'namespace::autoclean') {\n            $file_data = _util_dpush($file_data, 'depends_on', $1);\n        }\n    }\n    if ( $line =~ m/^\\s*use\\s+([\\w\\:]+)\\s(\\S+)/ ) {\n        if ( $1 eq 'parent' or $1 eq 'base' ) {\n            my $file = $2;\n            $file =~ s/\\'|\\;//g;\n            $file_data = _util_dpush($file_data, 'depends_on', $file);\n        }\n    }\n\n    if ($line =~ m/^\\s*require\\s+([^\\s;]+)/) { # \"require Bar;\" or \"require 'Foo/Bar.pm' if $wibble;'\n        my $required = $1;\n        if ($required =~ m/^([\\w\\:]+)$/) {\n            $file_data = _util_dpush($file_data, 'depends_on', $required);\n        }\n        elsif ($required =~ m/^[\"'](.*?\\.pm)[\"']$/) { # simple Foo/Bar.pm case\n            ($required = $1) =~ s/\\.pm$//;\n            $required =~ s!/!::!g;\n            $file_data = _util_dpush($file_data, 'depends_on', $required);\n        }\n        else {\n            warn \"Can't interpret $line at line $. in $file_data->{file}\\n\"\n                unless m!sys/syscall.ph!\n                    or m!dumpvar.pl!\n                    or $required =~ /^\\$/   # dynamic 'require'\n                    or $required =~ /^5\\./;\n        }\n    }\n\n    return $file_data;\n}\n\n=head2 _parse_inheritance\n\n\nsub _parse_inheritance {\n    my ($file_data, $line, $fh) = @_;\n   \n    # the 'use base/parent' pragma\n    if ($line =~ m/^\\s*use\\s+(base|parent)\\s+(.*)/) {\n        ( my $list = $2 ) =~ s/\\s+\\#.*//;\n        $list =~ s/[\\r\\n]//;\n        while ( $list !~ /;\\s*$/ && ( $_ = <$fh> ) ) {\n            s/\\s+#.*//; # remove any comments\n            s/[\\r\\n]//; # remove line endings\n            $list .= $_;\n        }\n        $list =~ s/;\\s*$//;\n        my (@mods) = Safe->new()->reval($list);\n        warn \"Unable to eval $line at line $. in $file_data->{file}: $@\\n\" if $@;\n        foreach my $mod (@mods) {\n            $file_data = _util_dpush($file_data, 'parent', $mod);\n        }\n    }\n\n    # there will be a way to make this better - but ....\n    if ($line =~ m/^extends\\s+(.*)/ ) {\n        ( my $list = $1 ) =~ s/\\s+\\#.*//;\n        $list =~ s/[\\r\\n]//;\n        my (@mods) = Safe->new()->reval($list);\n        foreach my $mod (@mods) {\n            $file_data = _util_dpush($file_data, 'parent', $mod);\n        }\n    }\n\n    if ($line =~ m/BEGIN\\s+\\{*\\s*extends\\s+'*([\\w\\:]+)'*\\s*\\}*/ ) {\n        ( my $list = $1 ) =~ s/\\s+\\#.*//;\n        $list =~ s/[\\r\\n]//;\n        my (@mods) = Safe->new()->reval($list);\n        foreach my $mod (@mods) {\n            $file_data = _util_dpush($file_data, 'parent', $mod);\n        }\n    }\n\n    return $file_data;\n}\n\n=head2 _parse_package","label":"_parse_package($file_data,$line)","parameters":[{"label":"$file_data"},{"label":"$line"}]},"name":"_parse_package"},{"range":{"start":{"character":0,"line":533},"end":{"line":537,"character":9999}},"containerName":"main::","detail":"($file_data,$key,$value)","kind":12,"children":[{"line":534,"definition":"my","name":"$file_data","localvar":"my","kind":13,"containerName":"_util_dpush"},{"kind":13,"line":534,"name":"$key","containerName":"_util_dpush"},{"name":"$value","containerName":"_util_dpush","kind":13,"line":534},{"localvar":"my","name":"$curr_pkg","definition":"my","line":536,"containerName":"_util_dpush","kind":13},{"line":536,"kind":13,"containerName":"_util_dpush","name":"$file_data"},{"containerName":"_util_dpush","name":"$file_data","line":537,"kind":13},{"line":537,"kind":13,"name":"$curr_pkg","containerName":"_util_dpush"},{"containerName":"_util_dpush","name":"$key","kind":13,"line":537}],"name":"_util_dpush","signature":{"parameters":[{"label":"$file_data"},{"label":"$key"},{"label":"$value"}],"label":"_util_dpush($file_data,$key,$value)","documentation":"# EOF\n#!/usr/bin/perl;\n\nuse strict;\nuse warnings;\n\nuse App::PrereqGrapher;\nuse Capture::Tiny ':all';\nuse Config::JSON;\nuse Cwd;\nuse DDP;\nuse DBI;\nuse File::Basename;\nuse Getopt::Long;\nuse JSON;\nuse Path::Tiny;\nuse Perl::Critic;\nuse Perl::Metrics::Simple;\nuse Pod::Simple::Search;\nuse Safe;\n\nmy $initialize = 0;\n\nGetOptions(\n    'initialize' => \\$initialize,\n);\n\nmy $dbh = DBI->connect(\"dbi:SQLite:critic.db\",\"\",\"\") or die \"Could not connect\";\n\n# initialize the environment\nif ( $initialize ) {\n    print( '**** PKI - initializing Database ****' . \"\\n\" );\n    print( '**** all existing data will be removed ****' . \"\\n\" );\n    _initialize_data();\n}\n\nmy $analyzer = Perl::Metrics::Simple->new;\nmy $libs;\n\n# try to import every .pm file in /lib\nmy $config = Config::JSON->new(\"./script/modulelib.conf\");\n\nmy $module_count = 0;\nforeach ( @{ $config->get( 'libs' ) } ) {\n    my $dpath = $_;\n    my $dir = path($dpath);\n    my $iter = $dir->iterator({\n        recurse         => 1,\n        follow_symlinks => 0,\n    });\n\n    while (my $path = $iter->()) {\n        next if $path->is_dir || $path !~ /\\.pm$/;\n        my $file = $path->relative;\n\n        my $module;\n        ( $module = $file ) =~ s/(^.+\\/lib\\/|\\.pm$)//g;\n        $module =~ s/\\//::/g;\n        $module =~ s/^:://g;\n\n        my ( $filename, undef, undef ) = fileparse( $file );\n        if ( _collect_git_data( path($path)->parent->stringify, $module, $filename, $config->get( 'git' ) ) ) {\n            next;\n        }\n\n        $module_count++;\n\n        my $pod_score = _collect_pod_data( $module, $file );\n        _collect_metrics_data( $module, $file, $pod_score );\n        _collect_critic_data( $module, $file );\n        _collect_use_data( $module, $file );\n    }\n\n    _collect_git_commit_data( $config->get( 'git' ) );\n}\n\nprint( '## ' . $0 . ' has completed.' . \"\\n\" );\nprint( '## modules processed : ' .  $module_count . \"\\n\\n\" );\n\n=head2 _collect_critic_data\n\n\nsub _collect_critic_data {\n    my ( $module, $file ) = @_;\n\n    my @critic_data = ();\n    my $critic = Perl::Critic->new( -severity => 3, -theme => \"maintenance\" ); \n    my @issues = $critic->critique($file->stringify); \n\n    foreach ( @issues ) { \n        push @critic_data, [ $_->description, $_->line_number, $_->source, $_->explanation ]; \n    }\n\n    my $query = \"insert into critic (module, critic, line_number, source, explanation) values(?, ?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @critic_data ) {\n        $stmt->execute( $module, $_->[0], $_->[1], $_->[2], $_->[3] );\n    }\n\n    return;\n}\n\n=head2 _collect_git_data\n\n\nsub _collect_git_data {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $gitlog, $stderr, $exit ) = capture {system(\n        \"git\", \n        \"log\", \n        \"--pretty=format: %h %ad %s | %an\", \n        \"--date=short\", \n        \"-20\", \n        \"--graph\", \n        \"--all\", \n        $full_filename\n    ) };\n\n    my $latest_git_commit_data;\n    ( $latest_git_commit_data, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename) };\n    my ( $latest_git_commit_sha, $commit_description ) = split(' ', $latest_git_commit_data );\n\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute(\n        $module\n    );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    $query = \"insert into gitlog (module, latest_commit_sha, log) values(?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    unless ( $initialize ) {\n        if ( $git_sha and $git_sha eq $latest_git_commit_sha ) {\n            return 1;\n        }\n    }\n\n    print( '## updating data for : ' . $module . \"\\n\" );\n    $stmt->execute(\n        $module,\n        $latest_git_commit_sha,\n        $gitlog\n    );\n\n    # reset our location\n    chdir( $cwd );\n\n    return 0;\n}\n\n=head2 _collect_git_commit_data\n\n\nsub _collect_git_commit_data {\n    my ( $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute( \n            $date, \n            $count\n        );\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return;\n}\n\n=head2 _collect_metrics_data\n\n\nsub _collect_metrics_data {\n    my ( $module, $file, $pod_score ) = @_;\n\n    my @file_array = ( $file->stringify );\n    my $analysis = $analyzer->analyze_files( @file_array );\n\n    my $query = \"insert into metrics (module, subname, complexity, lines) values(?, ?, ?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    foreach ( @{ $analysis->subs } ) {\n        if ( $_->{ mccabe_complexity } > 10 ) {\n            $stmt->execute( $module, $_->{ name }, $_->{ mccabe_complexity }, $_->{ lines } );\n        }\n    }\n\n    my $summary = $analysis->summary_stats;\n    my $lines   = $analysis->lines;\n    $query = \"insert into summary (module, avg_complexity, max_complexity, lines, pod, sub_count) values(?, ?, ?, ?, ?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( \n        $module, \n        $summary->{ sub_complexity }->{ mean } ? int($summary->{ sub_complexity }->{ mean } ) : 0, \n        $summary->{ sub_complexity }->{ max }, \n        $lines || 0, \n        $pod_score || 0,\n        $analysis->sub_count()\n    );\n\n    return;\n}\n\n=head2 _collect_module_hierarchy_data\n\n\nsub _collect_module_hierarchy_data {\n    my ( $module, $file ) = @_;\n\n    my ( $git_commits, $stderr, $exit ) = capture {system(\n        \"git log --date=short --pretty=format:%ad | sort | uniq -c\" ) };\n\n    my $query = \"insert into gitcommits (date, commits) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n\n    my @commits = split(\"\\n\", $git_commits);\n    foreach ( @commits ) {\n        $_ =~ s/^\\s+//;\n        my ( $count, $date ) = split( \" \", $_ );\n        $stmt->execute(\n            $date,\n            $count\n        );\n    }\n\n    return;\n}\n\n=head2 _collect_pod_data\n\nReturns a 1 / 0 depending on whether the B<file> contains POD\n\n\nsub _collect_pod_data {\n    my ( $module, $file ) = @_;\n\n    my $finder = Pod::Simple::Search->new;\n    if ( $finder->contains_pod( $file ) ) {\n        return 2;\n    }\n\n    return 1;\n}\n\n=head2 _collect_use_data\n\n\nsub _collect_use_data {\n    my ( $module, $file ) = @_;\n  \n    # go through the file and try to find out some things\n    open my $fh, '<', $file or do { warn(\"Can't open file $file for read: $!\"); return undef; };\n\n    (my $filename = $file) =~ s/^\\.//;\n\n    my $file_data = {\n        'file'          => $file,\n        'filename'      => $filename,\n        'data'          => {},\n        'seen'          => {},\n        'source'        => {},\n        'in_pod'        => undef,\n        'curr_pkg'      => undef,\n        'curr_method'   => undef,\n    };\n\n    while (<$fh>) {\n        s/\\r?\\n$//;\n        $file_data->{'in_pod'} = 1 if m/^=\\w+/ && !m/^=cut/;\n        if ($file_data->{'in_pod'}) {\n            $file_data->{'in_pod'} = 0 if /^=cut/;\n            next;\n        }\n        last if m/^\\s*__(END|DATA)__/;\n\n        _parse_package( $file_data, $_ );\n        \n        # skip lines which do not belong to package namespace\n        next if !$file_data->{'curr_pkg'};\n        \n        # append current line to package source\n        $file_data->{'source'}->{$file_data->{'curr_pkg'}} .= $_ . \"\\n\";\n\n        ## - all commented out for now - will be revisted ...\n        # count non-empty lines\n        #$self->count_package_lines($_);\n        \n        #$self->parse_sub($_);\n        #$self->parse_super($_);\n        #$self->parse_method_call($_);\n\n        _parse_dependencies( $file_data, $_ );\n\n        _parse_inheritance( $file_data, $_, $fh );\n    }\n    close $fh;\n\n    my $dependencies = $file_data->{data}->{$module}->{depends_on};\n    my $inheritance  = $file_data->{data}->{$module}->{parent};\n\n    my $query = \"insert into dependencies (module, dependencies) values(?, ?)\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($dependencies) );\n\n    $query = \"insert into inheritance (module, inheritance) values(?, ?)\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module, encode_json($inheritance) );\n\n    return $file_data->{'data'};\n}\n\n=head2 _get_latest_commit\n\n\nsub _get_latest_commit {\n    my ( $file, $module, $filename, $gitlib ) = @_;\n\n    # store _where I am_\n    my $cwd = getcwd();\n    my $full_filename = $file . '/' . $filename;\n\n    chdir( $gitlib );\n    my $gitdir = cwd;\n    my ( $latest_git_commit_sha, $stderr, $exit ) = capture {system(\n        \"git log -n1 --oneline \" . $full_filename . \" | awk '{print $1;}'\" ) };\n\n    # have I got a more recent commit ....\n    my $status = 0;\n    my $query = \"select latest_commit_sha from gitlog where module = ?\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute( $module );\n    my ( $git_sha ) = $stmt->fetchrow_array;\n\n    if ( $git_sha eq $latest_git_commit_sha ) {\n        $status = 1;\n    }\n\n    # reset our location\n    chdir( $cwd );\n\n    return $status;\n}\n\n=head2 _initialize_data\n\nReset everything before scanning the specified repos\n\n\nsub _initialize_data {\n    my $query = \"delete from critic\";\n    my $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from metrics\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from summary\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from dependencies\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from inheritance\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitlog\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    $query = \"delete from gitcommits\";\n    $stmt  = $dbh->prepare( $query );\n    $stmt->execute();\n\n    return;\n}\n\n=head2 _parse_dependencies\n\n\nsub _parse_dependencies {\n    my ($file_data, $line) = @_;\n    \n    # need to process 'use parent *****' in DBIX resultset classes.\n    if ( $line =~ m/^\\s*use\\s+([\\w\\:]+)/ ) {\n        if ( $1 ne \"strict\" and $1 ne \"warnings\" and $1 ne \"parent\" and $1 ne 'base' and $1 ne 'namespace::autoclean') {\n            $file_data = _util_dpush($file_data, 'depends_on', $1);\n        }\n    }\n    if ( $line =~ m/^\\s*use\\s+([\\w\\:]+)\\s(\\S+)/ ) {\n        if ( $1 eq 'parent' or $1 eq 'base' ) {\n            my $file = $2;\n            $file =~ s/\\'|\\;//g;\n            $file_data = _util_dpush($file_data, 'depends_on', $file);\n        }\n    }\n\n    if ($line =~ m/^\\s*require\\s+([^\\s;]+)/) { # \"require Bar;\" or \"require 'Foo/Bar.pm' if $wibble;'\n        my $required = $1;\n        if ($required =~ m/^([\\w\\:]+)$/) {\n            $file_data = _util_dpush($file_data, 'depends_on', $required);\n        }\n        elsif ($required =~ m/^[\"'](.*?\\.pm)[\"']$/) { # simple Foo/Bar.pm case\n            ($required = $1) =~ s/\\.pm$//;\n            $required =~ s!/!::!g;\n            $file_data = _util_dpush($file_data, 'depends_on', $required);\n        }\n        else {\n            warn \"Can't interpret $line at line $. in $file_data->{file}\\n\"\n                unless m!sys/syscall.ph!\n                    or m!dumpvar.pl!\n                    or $required =~ /^\\$/   # dynamic 'require'\n                    or $required =~ /^5\\./;\n        }\n    }\n\n    return $file_data;\n}\n\n=head2 _parse_inheritance\n\n\nsub _parse_inheritance {\n    my ($file_data, $line, $fh) = @_;\n   \n    # the 'use base/parent' pragma\n    if ($line =~ m/^\\s*use\\s+(base|parent)\\s+(.*)/) {\n        ( my $list = $2 ) =~ s/\\s+\\#.*//;\n        $list =~ s/[\\r\\n]//;\n        while ( $list !~ /;\\s*$/ && ( $_ = <$fh> ) ) {\n            s/\\s+#.*//; # remove any comments\n            s/[\\r\\n]//; # remove line endings\n            $list .= $_;\n        }\n        $list =~ s/;\\s*$//;\n        my (@mods) = Safe->new()->reval($list);\n        warn \"Unable to eval $line at line $. in $file_data->{file}: $@\\n\" if $@;\n        foreach my $mod (@mods) {\n            $file_data = _util_dpush($file_data, 'parent', $mod);\n        }\n    }\n\n    # there will be a way to make this better - but ....\n    if ($line =~ m/^extends\\s+(.*)/ ) {\n        ( my $list = $1 ) =~ s/\\s+\\#.*//;\n        $list =~ s/[\\r\\n]//;\n        my (@mods) = Safe->new()->reval($list);\n        foreach my $mod (@mods) {\n            $file_data = _util_dpush($file_data, 'parent', $mod);\n        }\n    }\n\n    if ($line =~ m/BEGIN\\s+\\{*\\s*extends\\s+'*([\\w\\:]+)'*\\s*\\}*/ ) {\n        ( my $list = $1 ) =~ s/\\s+\\#.*//;\n        $list =~ s/[\\r\\n]//;\n        my (@mods) = Safe->new()->reval($list);\n        foreach my $mod (@mods) {\n            $file_data = _util_dpush($file_data, 'parent', $mod);\n        }\n    }\n\n    return $file_data;\n}\n\n=head2 _parse_package\n\n\nsub _parse_package {\n    my ($file_data, $line) = @_;\n\n    # get the package name\n    if ($line =~ m/^\\s*package\\s+([\\w\\:]+)\\s*;/) {\n        my $curr_pkg = $1;\n        $file_data->{'curr_pkg'} = $curr_pkg;\n        $file_data->{'data'}->{$curr_pkg} = {\n            'filename'         => $file_data->{'filename'},\n            'filerootdir'      => $file_data->{'rootdir'},\n            'package'          => $curr_pkg,\n            'line_count'       => 0,\n            'depends_on'       => [],\n            'parent'           => [],\n            'methods'          => [],\n            'methods_super'    => [],\n            'methods_used'     => {},\n            'constants'        => {},\n            'fields'           => [],\n        };\n    }\n\n    return $file_data;\n}\n\n=head2 _util_dpush"},"line":533,"definition":"sub"},{"containerName":null,"name":"$value","kind":13,"line":538},{"kind":13,"line":538,"name":"%file_data","containerName":null},{"line":538,"kind":13,"name":"%curr_pkg","containerName":null},{"name":"%key","containerName":null,"line":538,"kind":13},{"kind":13,"line":538,"containerName":null,"name":"$value"},{"containerName":null,"name":"$file_data","line":540,"kind":13}]}